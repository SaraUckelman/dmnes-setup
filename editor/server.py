#!/usr/bin/python -3

##!/usr/bin/python3 -b

import itertools
import os
#import subprocess
import subprocess32 # use until we move to Python 3
import traceback
import unicodedata

import werkzeug.security

from flask import Flask, Response, abort, flash, redirect, render_template, request, session, url_for

import lxml
from lxml.builder import E

app = Flask(__name__)
app.config.from_object(__name__)

app.config.update(dict(
  REPO_URL='git@github.com:uckelman/test.git',
  USERS_DIR='users',
  CNF_DIR='CNFs',
  VNF_DIR='VNFs',
  BIB_DIR='bib',
  CNF_SCHEMA='schemata/cnf.xsd',
  VNF_SCHEMA='schemata/vnf.xsd',
  SECRET_KEY=os.urandom(128),
  DEBUG=False
))

# password hash generated by:
#
#   werkzeug.security.generate_password_hash('password')
#

#
# User accounts
#

class User(object):
  def __init__(self, username, pwhash, realname, email):
    self.username = username
    self.pwhash = pwhash
    self.realname = realname
    self.email = email

  def check_password(self, password):
    return werkzeug.security.check_password_hash(self.pwhash, password)


# TODO: move accounts out of the source
accounts = {
  'liana': User(
    'liana',  # yoIN3i)2k
    'pbkdf2:sha1:1000$N64I7Fg1$5ed44d1125456db5a6ab8a36f88f0577a9f91e13',
    'Sara L. Uckelman',
    'liana@ellipsis.cx'
  ),
  'uckelman': User(
    'uckelman',
    'pbkdf2:sha1:1000$fPQl6n0t$3988730ff8770775e31ca325758b5e059684ca4b',
    'Joel Uckelman',
    'uckelman@nomic.net'
  ),
}


#
# XML schemas
#

def load_schema(filename):
  with open(filename) as f:
    doc = lxml.etree.parse(f)
  return lxml.etree.XMLSchema(doc)

#
# shell out
#

class SubprocessError(subprocess32.CalledProcessError):
  def __init__(self, **kwargs):
    super(SubprocessError, self).__init__(**kwargs)


  def __str__(self):
    indent = '  '
    return '{}\n\nOutput:\n{}{}'.format(
      super(SubprocessError, self).__str__(),
      indent,
      ('\n' + indent).join(self.output.splitlines())
    )


def do_cmd(cwd, *args):
  with subprocess32.Popen(
    args,
    cwd=cwd,
    stdout=subprocess32.PIPE,
    stderr=subprocess32.STDOUT
  ) as proc:
    out = proc.communicate(timeout=10)[0]
    if proc.returncode:
      raise SubprocessError(
        returncode=proc.returncode,
        cmd=args,
        output=out
      )

  return '% {}\n{}'.format(' '.join(args), out)


#
# bib lookup
#

def get_bibkeys(repo_dir):
  bib_dir = app.config['BIB_DIR']
  res = do_cmd(repo_dir, 'grep', '-hoPr', '<key>\\K[^<]+', bib_dir)
# FIXME: adjust do_cmd to make it possible to get output only
  keys = res.splitlines()[1:]
  keys.sort()
  return keys


#
# Git functions
#

def do_git(repo_dir, cmd, *args):
  out = do_cmd(repo_dir, 'git', cmd, *args)
  flash(out, 'git')


def git_clone(base_dir, repo_url, repo_dir):
  do_git(base_dir, 'clone', repo_url, repo_dir)


def git_config(repo_dir, *args):
  do_git(repo_dir, 'config', *args)


def git_config_user(repo_dir, name, email):
  do_git(repo_dir, 'config', 'user.name', name)
  do_git(repo_dir, 'config', 'user.email', email)


#def git_clone_branch(base_dir, repo_url, repo_dir, branch):
#  do_git(base_dir, 'clone', '-b', branch, '--single-branch', repo_url, repo_dir)


def git_checkout_branch(repo_dir, branch):
  do_git(repo_dir, 'checkout', '-B', branch)


def git_add_file(repo_dir, path):
  do_git(repo_dir, 'add', path)


def git_commit_file(repo_dir, author, msg, path):
  do_git(repo_dir, 'commit', '--author', author, '-m', msg, path)


def git_pull(repo_dir, repo, refspec):
  do_git(repo_dir, 'pull', repo, refspec)


def git_push(repo_dir, repo, refspec):
  do_git(repo_dir, 'push', repo, refspec)


#
#
#

def prefix_branch(s, maxlen=3):
  return [s[n-1:n] for n in range(1,maxlen+1)] + [s]


def sanitize_filename(filename):
  filename = unicodedata.normalize('NFKC', unicode(filename).lower())
  if len(filename) > 255:
    raise RuntimeError('Evil path: ' + filename)
  for evil in os.pardir, os.sep, os.altsep:
    if evil and evil in filename:
      raise RuntimeError('Evil path: ' + filename)
  return filename


def build_prefix_path(basedir, basename):
  basename = sanitize_filename(basename)
  return os.path.join(basedir, *prefix_branch(basename)) + '.xml'


def cnf_path(cnf):
  return build_prefix_path(app.config['CNF_DIR'], cnf['nym'][0])


def vnf_path(vnf):
  return build_prefix_path(
    app.config['VNF_DIR'],
    '{}_{}_{}'.format(vnf['name'][0], vnf['date'][0], vnf['bib_key'][0])
  )


def bib_path(bib):
  return os.path.join(
    app.config['BIB_DIR'],
    sanitize_filename(bib['key'][0])
  )


def elements(key, obj):
  try:
    return (E(key, val) for val in obj[key] if val)
  except KeyError:
    return ()


def elements_raw_inner(key, obj):
  try:
    return (
      lxml.etree.fromstring('<{0}>{1}</{0}>'.format(key, val))
      for val in obj[key] if val
    )
  except KeyError:
    return ()


def indent(node, depth):
  node.text = '\n' + '  '*(depth+1)
  for e in node[:-1]:
    e.tail = '\n' + '  '*(depth+1)
  node[-1].tail = '\n' + '  '*depth


def cnf_build(cnf, schema):
  root = E.cnf(*tuple(itertools.chain(
    elements('nym', cnf),
    elements('gen', cnf),
    elements_raw_inner('etym', cnf),
    elements_raw_inner('usg', cnf),
    elements_raw_inner('def', cnf),
    elements_raw_inner('note', cnf)
  )))

  indent(root, 0)

  schema.assertValid(root)
  return lxml.etree.ElementTree(root)


def vnf_build(vnf, schema):
  root = E.vnf(*tuple(itertools.chain(
    elements('name', vnf),
    elements('nym', vnf),
    elements('gen', vnf),
    elements('case', vnf),
    elements('lang', vnf),
    elements_raw_inner('place', vnf),
    elements('date', vnf),
    (E.bibl(
      E.key(k),
      E.loc(l)
    ) for k, l in zip(vnf['bib_key'], vnf['bib_loc'])),
    elements_raw_inner('note', vnf)
  )))

  indent(root, 0)
  indent(root.find('bibl'), 1)

  schema.assertValid(root)
  return lxml.etree.ElementTree(root)


def bib_build(bib, schema):
  root = E.bibl(*tuple(itertools.chain(
    elements('key', bib),
    (lxml.etree.fromstring(val) for val in bib['entry'] if val)
  )))

  indent(root, 0)
  indent(root[1], 1)

  return lxml.etree.ElementTree(root)


def write_tree(tree, path):
  try:
    os.makedirs(os.path.dirname(path))
  except os.error:
    pass
# Python 3:
#  os.makedirs(os.path.dirname(path), exist_ok=True)
  with open(path, 'wb') as f:
    tree.write(
      f,
      xml_declaration='<?xml version="1.0" encoding="UTF-8"?>',
      encoding='UTF-8',
      pretty_print=False
    )


def repo_for(username):
  return os.path.join(app.config['USERS_DIR'], username)


def prepare_git(username):
  upath = repo_for(username)
  repo_exists = os.path.isdir(upath)

  if not repo_exists:
    # set up local repo
    git_clone(app.config['USERS_DIR'], app.config['REPO_URL'], username)
    user = accounts[username]
    git_config_user(upath, user.realname, user.email)
    git_config(upath, 'push.default', 'simple')

  git_checkout_branch(upath, username)

  if repo_exists:
    # ensure existing repo is current
    git_pull(upath, 'origin', username)
    git_pull(upath, 'origin', 'master')
 

def commit_to_git(username, path, tree):
  upath = repo_for(username)
  write_tree(tree, os.path.join(upath, path))
  git_add_file(upath, path)
  user = accounts[username]
  author = '{} <{}>'.format(user.realname, user.email)
  msg = 'Added ' + path
  git_commit_file(upath, author, msg, path)


def push_back_to_git(username):
  upath = repo_for(username)
  git_push(upath, 'origin', username + ':' + username) 


# TODO: handle exceptions

#
# User authentication
#

def auth_user(username, password):
  user = accounts.get(username, None)
  return user and user.check_password(password)


#
#
#

def request_size(req):
  return sum(len(v) for v in req.values())


#
# URL handlers
#

@app.route('/')
def slash():
  return 'Welcome to the DMNES!'


@app.route('/login', methods=['GET', 'POST'])
def login():
  error = None
  if request.method == 'POST':
    username = request.form['username']
    password = request.form['password']

    if auth_user(username, password):
      session['username'] = username
      prepare_git(username)
      flash('Welcome, ' + username + '.', 'notice')
      return redirect(url_for('cnf'))
    else:
      flash('Invalid username or password!', 'error')

  return render_template('login.html', vals={})


@app.route('/logout')
def logout():
  username = session.pop('username', None)
  if username:
    push_back_to_git(username)
    flash('Goodbye, ' + username + '.', 'notice')
  return redirect(url_for('login'))


@app.route('/bibkeys', methods=['GET'])
def handle_bibkeys_request():
  if 'username' not in session:
    abort(401)

  username = session['username']
  keys = '\n'.join(get_bibkeys(repo_for(username)))
  return Response(keys, mimetype='text/plain')


class FormStruct:
  def __init__(self, path_func, schema, build_func, cn_func, keepers, templ):
    self.path_func = path_func
    self.schema = schema
    self.build_func = build_func
    self.cn_func = cn_func
    self.keepers = keepers
    self.templ = templ


CNF = FormStruct(
  cnf_path,
  load_schema(app.config['CNF_SCHEMA']),
  cnf_build,
  lambda x: x['nym'][0],
  (),
  'cnf.html'
)

VNF = FormStruct(
  vnf_path,
  load_schema(app.config['VNF_SCHEMA']),
  vnf_build,
  lambda x: x['name'][0],
  ('lang', 'place', 'date', 'bib_key'),
  'vnf.html'
)

BIB = FormStruct(
  bib_path,
#  load_schema(app.config['BIB_SCHEMA']),
  None,
  bib_build,
  lambda x: x['key'][0],
  (),
  'bib.html'
)


class FormError(Exception):
  def __init__(self, message):
    super(FormError, self).__init__()
    self.message = message


def handle_entry_form(fstruct):
  if 'username' not in session:
    abort(401)

  vals = {}

  if request.method == 'POST':
    try:
      if request_size(request.form) > 2048:
        abort(413)

      # strip leading and trailing whitespace from form input
      form = {k: [v.strip() for v in l] for k, l in request.form.iterlists()}

      username = session['username']
      localpath = fstruct.path_func(form)
      fullpath = os.path.join(repo_for(username), localpath)

      # don't clobber existing entries
      if os.path.exists(fullpath):
        raise FormError(fullpath + ' already exists')

      # validate the entry
      try:
        tree = fstruct.build_func(form, fstruct.schema)
      except lxml.etree.DocumentInvalid as e:
        raise FormError(unicode(e))

      # write the entry and report that
      commit_to_git(username, localpath, tree)
      flash('Added ' + fstruct.cn_func(form), 'notice')

      # retain some input values for next entry
      vals = {k: request.form[k] for k in fstruct.keepers}

    except FormError as e:
      flash(e.message, 'error')
      # retain all input values on error
      vals = request.form

  return render_template(fstruct.templ, vals=vals)


@app.route('/cnf', methods=['GET', 'POST'])
def cnf():
  return handle_entry_form(CNF)


@app.route('/vnf', methods=['GET', 'POST'])
def vnf():
  return handle_entry_form(VNF)


@app.route('/bib', methods=['GET', 'POST'])
def bib():
  return handle_entry_form(BIB)


@app.errorhandler(Exception)
def handle_exception(ex):
  ex_text = traceback.format_exc()
  return render_template('exception.html', ex=ex_text), 500


if __name__ == '__main__':
  app.run()
